#!/bin/bash

# Загрузка конфигурации
CONFIG_FILE="/etc/system_monitor/system_monitor.conf"
if [ ! -f "$CONFIG_FILE" ]; then
    echo "Config file not found: $CONFIG_FILE" >&2
    exit 1
fi

# Функция для парсинга конфига
get_config() {
    awk -F ' = ' -v section="$1" -v key="$2" '
        $0 ~ /^\[.*\]/ {
            gsub(/\[|\]/, "", $0)
            current_section = $0
        }
        current_section == section && $1 == key {
            gsub(/\"/, "", $2)
            print $2
        }
    ' "$CONFIG_FILE"
}

# Инициализация переменных
LOG_DIR=$(get_config "main" "log_dir")
PID_FILE=$(get_config "main" "pid_file")
INTERFACES=$(get_config "network" "interfaces" | tr ',' ' ')

# Создаем директории и файлы
mkdir -p "$LOG_DIR" || { echo "Cannot create log directory" >&2; exit 1; }
touch "$PID_FILE" || { echo "Cannot create pid file" >&2; exit 1; }

# Функция логирования
log() {
    local log_file="$LOG_DIR/$1.log"
    local message="$2"
    echo "$(date "+%b %d %H:%M:%S") $message" >> "$log_file"
}

# Мониторинг CPU, RAM и температуры
monitor_cpu_ram_temp() {
    local interval=$(get_config "intervals" "cpu_ram")
    local temp_paths=(
        "/sys/class/thermal/thermal_zone0/temp"
        "/sys/class/thermal/thermal_zone1/temp"
    )

    while true; do
        cpu_usage=$(top -bn1 | awk '/Cpu\(s\)/ {print 100 - $8}')
        ram_usage=$(free | awk '/Mem/ {printf "%.1f%%", $3/$2*100}')

        local temps=()
        for path in "${temp_paths[@]}"; do
            if [ -f "$path" ]; then
                temp=$(awk '{printf "%.1f", $1/1000}' "$path")
                [ -n "$temp" ] && temps+=("$temp")
            fi
        done

        local temp_str="N/A"
        if [ ${#temps[@]} -eq 1 ]; then
            temp_str="${temps[0]}\u00b0C"
        elif [ ${#temps[@]} -eq 2 ]; then
            temp_str="CPU:${temps[0]}\u00b0C SOC:${temps[1]}\u00b0C"
        fi

        log "cpu_stats" "CPU:${cpu_usage}% RAM:${ram_usage} ${temp_str}"

        if command -v bc >/dev/null && [ -n "${temps[0]}" ] && [ "$(echo "${temps[0]} > 80" | bc -l)" -eq 1 ]; then
            log "alerts" "WARNING: High temperature detected: ${temps[0]}\u00b0C"
        fi

        sleep "$interval"
    done
}

# Мониторинг перезагрузки
check_reboot() {
    local last_boot=$(who -b | awk '{print $3,$4}')
    log "system" "Последняя загрузка системы: $last_boot"

    if journalctl -b -1 | grep -q "unexpected shutdown"; then
        log "alerts" "ВНИМАНИЕ: Неожиданное завершение работы системы"
    fi
}

# Мониторинг SSH
monitor_ssh() {
    local interval=60
    local max_failures=3
    local failure_count=0

    while true; do
        if ! ss -tnl | grep -q ':22'; then
            ((failure_count++))
            log "ssh" "Ошибка подключения SSH (попытка $failure_count/$max_failures)"

            if [ $failure_count -ge $max_failures ]; then
                log "ssh" "Критическая ошибка SSH - перезапуск сервиса"
                systemctl restart ssh
                failure_count=0
            fi
        else
            failure_count=0
        fi
        sleep "$interval"
    done
}

# Мониторинг диска
monitor_disk() {
    local interval=$(get_config "intervals" "disk")

    while true; do
        df -h | awk '
        NR>1 {
            use=$5;
            gsub("%","",use);
            if(use > 90) {
                print "CRITICAL: "$6" at "use"%"
            } else if(use > 80) {
                print "WARNING: "$6" at "use"%"
            }
        }' | while read -r alert; do
            log "disk_alerts" "$alert"
        done
        sleep "$interval"
    done
}

# Мониторинг сети
monitor_network() {
    local interval=$(get_config "intervals" "network")
    while true; do
        for iface in $INTERFACES; do
            if ip link show "$iface" | grep -q "state UP"; then
                status="UP"
            else
                status="DOWN"
            fi

            ips=$(ip -4 -o addr show "$iface" 2>/dev/null | awk '{print $4}' | paste -sd ',')

            if [ -z "$ips" ]; then
                log_msg="$iface: $status"
            else
                log_msg="$iface: $status ($ips)"
            fi

            log "network" "$log_msg"
        done
        sleep "$interval"
    done
}

# Запуск мониторинга
monitor_cpu_ram_temp & echo $! >> "$PID_FILE"
monitor_network & echo $! >> "$PID_FILE"
monitor_disk & echo $! >> "$PID_FILE"
check_reboot
monitor_ssh & echo $! >> "$PID_FILE"

# Ожидание завершения процессов
wait

# Лог systemd сообщений о падении служб
if ($syslogtag == 'systemd' or $programname == 'systemd') and \
   (msg contains 'Failed' or msg contains 'failure' or msg contains 'failed') then {
    /var/log/system-monitor/failed-services.log
    stop
}


# Функция для парсинга конфига
get_config() {
    awk -F ' = ' -v section="$1" -v key="$2" '
        $0 ~ /^\[.*\]/ {
            gsub(/\[|\]/, "", $0)
            current_section = $0
        }
        current_section == section && $1 == key {
            gsub(/\"/, "", $2)
            print $2
        }
    ' "$CONFIG_FILE"
}
● system-monitor.service - System Monitoring Service
     Loaded: loaded (/etc/systemd/system/system-monitor.service; enabled; vendor preset: enabled)
     Active: active (running) since Mon 2025-05-05 15:33:34 UTC; 17s ago
   Main PID: 2763998 (system-monitor.)
      Tasks: 9 (limit: 2271)
     Memory: 3.4M
     CGroup: /system.slice/system-monitor.service
             ├─2763998 /bin/bash /usr/local/bin/system-monitor.sh
             ├─2764010 /bin/bash /usr/local/bin/system-monitor.sh
             ├─2764011 /bin/bash /usr/local/bin/system-monitor.sh
             ├─2764013 /bin/bash /usr/local/bin/system-monitor.sh
             ├─2764047 /bin/bash /usr/local/bin/system-monitor.sh
             ├─2764053 sleep 60
             ├─2764239 sleep 30
             ├─2783142 sleep 3
             ├─2785510 df -h
             ├─2785511 /bin/bash /usr/local/bin/system-monitor.sh
             └─2785512 /bin/bash /usr/local/bin/system-monitor.sh

May 05 15:33:51 zephyr system-monitor[2785490]: sleep: invalid time interval ‘’
May 05 15:33:51 zephyr system-monitor[2785490]: Try 'sleep --help' for more information.
May 05 15:33:51 zephyr system-monitor[2785494]: sleep: invalid time interval ‘’
May 05 15:33:51 zephyr system-monitor[2785494]: Try 'sleep --help' for more information.
May 05 15:33:51 zephyr system-monitor[2785498]: sleep: invalid time interval ‘’
May 05 15:33:51 zephyr system-monitor[2785498]: Try 'sleep --help' for more information.
May 05 15:33:51 zephyr system-monitor[2785502]: sleep: invalid time interval ‘’
May 05 15:33:51 zephyr system-monitor[2785502]: Try 'sleep --help' for more information.
May 05 15:33:51 zephyr system-monitor[2785509]: sleep: invalid time interval ‘’
May 05 15:33:51 zephyr system-monitor[2785509]: Try 'sleep --help' for more information.

[main]
log_dir = /var/log/system_monitor
pid_file = /var/run/system_monitor.pid

[intervals]
cpu_ram = 30
services = 10
kernel = 10
network = 3

[network]
interfaces = eth0,wlan0


get_config() {
    local section="$1"
    local key="$2"
    local in_section=0
    while IFS= read -r line; do
        # Удаление пробелов по краям
        line="$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

        # Пропуск пустых строк и комментариев
        [[ -z "$line" || "$line" =~ ^# ]] && continue

        # Поиск секции
        if [[ "$line" =~ ^\[(.*)\]$ ]]; then
            [[ "${BASH_REMATCH[1]}" == "$section" ]] && in_section=1 || in_section=0
            continue
        fi

        # Поиск ключа внутри нужной секции
        if [[ $in_section -eq 1 && "$line" =~ ^$key[[:space:]]*=[[:space:]]*(.*)$ ]]; then
            echo "${BASH_REMATCH[1]}" | tr -d '"'
            return
        fi
    done < "$CONFIG_FILE"
}

# Мониторинг systemd (падения служб)
:programname, startswith, "systemd" {
    /var/log/system_monitor/systemd.log
    stop
}

# Фильтр для критических сообщений systemd
:msg, contains, "failed" /var/log/system_monitor/systemd_errors.log
:msg, contains, "Failed" /var/log/system_monitor/systemd_errors.log

# Перенаправление roslaunch логов
:programname, startswith, "roslaunch" {
    /var/log/system_monitor/roslaunch.log
    stop
}

# Логирование ошибок ROS
:programname, startswith, "ros" {
    if $msg contains "ERROR" then {
        /var/log/system-monitor/ros_errors.log
    }
    stop
}

# exclude = nfs-idmapd|dnsmasq|systemd-networkd-wait-online

